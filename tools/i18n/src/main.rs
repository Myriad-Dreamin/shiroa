//! based on project https://github.com/frozolotl/typst-mutilate
//! LICENSE: European Union Public License 1.2
use std::{
    io::{self, Read, Write},
    path::PathBuf,
};

use argh::FromArgs;
use typst_syntax::{ast, SyntaxKind, SyntaxNode};

/// A tool to replace all words in a typst document with random garbage.
#[derive(FromArgs)]
struct Args {
    /// a file to perform in-place replacement on
    #[argh(option, short = 's')]
    src: Option<PathBuf>,
    /// a file to perform in-place replacement on
    #[argh(option, short = 'd')]
    dst: Option<PathBuf>,
    /// an ISO 639-1 language code, like `de`
    #[argh(option, short = 'l', default = r#"String::from("en")"#)]
    _language: String,
    /// whether to replace elements that are more likely to change behavior,
    /// like strings
    #[argh(switch, short = 'a')]
    aggressive: bool,
}

fn main() -> io::Result<()> {
    let args: Args = argh::from_env();

    let mut code = String::new();
    if let Some(path) = &args.src {
        code = std::fs::read_to_string(path)?;
    } else {
        std::io::stdin().read_to_string(&mut code)?;
    }

    let mut tr = Translator::build_context(&args)?;

    let syntax = typst_syntax::parse(&code);
    let errors = syntax.errors();
    if !errors.is_empty() {
        eprintln!("Syntax errors: {:?}", errors);
        return Ok(());
    }

    writeln!(
        tr.translated,
        "//! This file is generated by `typst-book-i18n`."
    )?;
    writeln!(tr.translated, r##"#import "/contrib/typst/i18n.typ": *"##)?;
    writeln!(tr.translated, r##"#{{ // begin of translation block"##)?;
    writeln!(tr.output, "#let lang = \"{}\"", args._language)?;
    if let Some(path) = &args.dst {
        let tr_path = path
            .with_extension("tr.typ")
            .file_name()
            .unwrap()
            .to_owned();
        writeln!(tr.output, r##"#include {:?}"##, tr_path)?;
        writeln!(tr.output, "#import {:?}: translate", tr_path)?;
        tr.translate_syntax(&syntax)?;
        std::fs::create_dir_all(path.parent().unwrap())?;
        writeln!(tr.translated, r##"}} // end of translation block"##)?;
        writeln!(tr.translated, "#let translate = translate")?;
        std::fs::write(path.with_extension("tr.typ"), &tr.translated)?;
        std::fs::write(path, &tr.output)?;
    } else {
        panic!("No destination file specified.");
    }

    Ok(())
}

struct Translator {
    aggressive: bool,
    // language: Lang,
    output: Vec<u8>,
    translate_id: usize,
    translated: Vec<u8>,
}

impl Translator {
    fn build_context(args: &Args) -> io::Result<Self> {
        // let language = {
        //     if args.language.len() != 2 {
        //         panic!("Language is not two ascii characters long.");
        //     }
        //     let bytes = args.language.as_bytes();
        //     Lang::from_iso([bytes[0], bytes[1]]).expect("language not supported")
        // };

        Ok(Self {
            aggressive: args.aggressive,
            output: Vec::new(),
            translate_id: 1,
            translated: Vec::new(),
            // language,
        })
    }

    fn translate_syntax(&mut self, syntax: &SyntaxNode) -> io::Result<()> {
        match syntax.kind() {
            SyntaxKind::Text => self.translate_text(syntax.text()),
            SyntaxKind::LineComment => {
                write!(self.output, "//")?;
                let content = &syntax.text()[2..];
                write!(self.output, "{content}")?;
                // self.translate_text(content)?;
                Ok(())
            }
            SyntaxKind::BlockComment => {
                write!(self.output, "/*")?;
                let content = &syntax.text()[2..syntax.text().len() - 2];
                write!(self.output, "{content}")?;
                // self.translate_text(content)?;
                write!(self.output, "*/")?;
                Ok(())
            }
            SyntaxKind::Str if self.aggressive => {
                write!(self.output, "\"")?;
                let content = &syntax.text()[1..syntax.text().len() - 1];
                self.translate_text(content)?;
                write!(self.output, "\"")?;
                Ok(())
            }
            SyntaxKind::Raw => {
                let raw: ast::Raw = syntax.cast().unwrap();
                let backticks = syntax.text().split(|c| c != '`').next().unwrap();
                write!(self.output, "{backticks}")?;

                let mut text = syntax
                    .text()
                    .trim_start_matches('`')
                    .strip_suffix(backticks)
                    .unwrap();
                if let Some(lang) = raw.lang() {
                    text = text.strip_prefix(lang).unwrap();
                    write!(self.output, "{lang}")?;
                }

                // will not translate text inside raw blocks
                write!(self.output, "{text}")?;
                // self.translate_text(text, self.output)?;
                write!(self.output, "{backticks}")?;
                Ok(())
            }
            SyntaxKind::Link => {
                let (scheme, rest) = syntax.text().split_once(':').unwrap();
                write!(self.output, "{scheme}:")?;
                self.translate_text(rest)
            }
            SyntaxKind::ModuleInclude | SyntaxKind::ModuleImport => self.write_node(syntax),
            _ if syntax.children().next().is_some() => {
                for child in syntax.children() {
                    self.translate_syntax(child)?;
                }
                Ok(())
            }
            _ => self.write_node(syntax),
        }
    }

    fn translate_text(&mut self, text: &str) -> io::Result<()> {
        let tid = self.translate_id;
        self.translate_id += 1;
        writeln!(
            self.translated,
            "  let t{tid} = translating([{text}], flow_id: {tid})"
        )?;
        writeln!(
            self.translated,
            "  translated((t{tid}, ),\n    [{text}]\n  )"
        )?;
        write!(self.output, "#translate([{text}], flow_id: {tid})")?;
        Ok(())
    }

    fn write_node(&mut self, syntax: &SyntaxNode) -> io::Result<()> {
        if syntax.children().next().is_some() {
            for child in syntax.children() {
                self.write_node(child)?;
            }
        } else {
            write!(self.output, "{}", syntax.text())?;
        }
        Ok(())
    }
}
